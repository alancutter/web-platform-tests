<!DOCTYPE html>
<meta charset=utf-8>
<title>Tests for updating the finished state of an animation</title>
<link rel="help" href="https://w3c.github.io/web-animations/#updating-the-finished-state">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<body>
<script>
'use strict';

function validateFinishEvent(t, event, animation) {
  t.step(function() {
    assert_equals(event.target, animation, "Animation should be event target");
    assert_times_equal(event.currentTime, animation.currentTime, "Event currentTime should be animation currentTime");
    assert_times_equal(event.timelineTime, animation.timeline.currentTime, "Event timelineTime should be animation timeline's currentTime");
  });
}

function awaitFinishEventAndPromise(t, animation) {
  var eventPromise = new Promise(function(resolve) {
    animation.onfinish = function(event) {
      validateFinishEvent(t, event, animation);
      resolve();
    };
  });

  var finishedPromise = animation.finished.then(function(target) {
    assert_equals(target, animation);
  });

  return Promise.all([eventPromise, finishedPromise]);
}

async_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate(null, 1);
  animation.onfinish = function(event) {
    t.unreached_func("Seeking to finish should not fire finish event");
  };
  animation.finished.then(function() {
    t.unreached_func("Seeking to finish should not resolve finished promise");
  })
  animation.finish();
  animation.currentTime = 0;
  animation.pause();
  t.done();
}, "Finish notification steps don't run when the animation seeks to finish and then seeks back again");

async_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate(null, 1);
  animation.onfinish = function(event) {
    t.unreached_func("Seeking past finish should not fire finish event");
  };
  animation.finished.then(function() {
    t.unreached_func("Seeking past finish should not resolve finished promise");
  })
  animation.currentTime = 10;
  animation.currentTime = 0;
  animation.pause();
  t.done();
}, "Finish notification steps don't run when the animation seeks past finish and then seeks back again");

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate(null, 1);
  animation.finish();
  return awaitFinishEventAndPromise(t, animation);
}, "Finish notification steps run when the animation completes with .finish()");

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate(null, 1);
  animation.currentTime = 10;
  return awaitFinishEventAndPromise(t, animation);
}, "Finish notification steps run when the animation seeks past finish");

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate(null, 1);
  return awaitFinishEventAndPromise(t, animation);
}, "Finish notification steps run when the animation completes");

promise_test(function(t) {
  var animation = createDiv(t).animate(null, 1);
  var firstPromise = animation.finished;

  return firstPromise.then(function(target) {
    animation.currentTime = 0;
    assert_not_equals(firstPromise, animation.finished);
    return animation.finished;
  });
}, "Animation finished promise is replaced after seeking back to start");

promise_test(function(t) {
  var animation = createDiv(t).animate(null, 1);
  var firstPromise = animation.finished;

  return firstPromise.then(function(target) {
    animation.play();
    assert_not_equals(firstPromise, animation.finished);
    return animation.finished;
  });
}, "Animation finished promise is replaced after replaying from start");

async_test(function(t) {
  var animation = createDiv(t).animate(null, 1);
  animation.onfinish = function(event) {
    animation.currentTime = 0;
    animation.onfinish = function(event) {
      t.done();
    };
  };
}, "Animation finish event is fired again after seeking back to start");

async_test(function(t) {
  var animation = createDiv(t).animate(null, 1);
  animation.onfinish = function(event) {
    animation.play();
    animation.onfinish = function(event) {
      t.done();
    };
  };
}, "Animation finish event is fired again after replaying from start");

</script>
</body>
